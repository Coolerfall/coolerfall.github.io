[{"title":"在Linux下进行开发工作（三）","url":"%2F2018%2F10%2F22%2Fwork-on-linux-part-three%2F","content":"\n{% post_link work-on-linux-part-two %}中记录了Manjaro日常使用中的一些常用软件和配置。基本可以在Linux进行开发了，不过由于屏幕适配以及字体的问题，会出现字体发虚，太小等等问题（4k屏以上一般来说不会有这些问题，但也不排除有个别情况），在Manjaro上的中文展示不是特别理想。这一篇主要记录下如何通过配置来调优字体显示，以适配自己的电脑。依然那句话，如果没准备好用Linux作为日常开发桌面，千万不要尝试 : )。\n<!-- more -->\n\n\n#### 字体安装\n首先找一个能够对中文展示比较友好字体，几番寻找，找到了`Noto Sans CJK`，也有人使用`文泉驿微米黑`，不过我试用了几天，还是觉得`Noto`系列看起来舒服些（这就看个人喜好了），这些字体都可以直接使用`pacman`安装：\n```shell\n$ sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji wqy-microhei  \n```\n\n#### 配置字体\n在`$HOME/.config/fontconfig/fonts.conf`（若没有则创建，若存在则覆盖）中添加如下配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE fontconfig SYSTEM \"fonts.dtd\">\n\n<fontconfig>\n\n  <match target=\"font\">\n    <edit mode=\"assign\" name=\"rgba\">\n      <const>rgb</const>\n    </edit>\n  </match>\n\n  <match target=\"font\">\n    <edit mode=\"assign\" name=\"hintstyle\">\n      <const>hintfull</const>\n    </edit>\n  </match>\n\n  <match target=\"font\">\n    <edit mode=\"assign\" name=\"antialias\">\n      <bool>true</bool>\n    </edit>\n  </match>\n\n  <match target=\"font\">\n    <edit name=\"lcdfilter\" mode=\"assign\">\n      <const>lcddefault</const>\n    </edit>\n  </match>\n\n  <!-- Default font (no fc-match pattern) -->\n  <match>\n    <edit mode=\"prepend\" name=\"family\">\n      <string>Noto Sans Mono</string>\n    </edit>\n  </match>\n\n  <!-- Default font for the zh_CN locale (no fc-match pattern) -->\n  <match>\n    <test compare=\"contains\" name=\"lang\">\n      <string>zh_CN</string>\n    </test>\n    <edit mode=\"prepend\" name=\"family\">\n      <string>Noto Sans CJK SC</string>\n    </edit>\n  </match>\n\n  <!-- Default sans-serif font -->\n  <match target=\"pattern\">\n    <test qual=\"any\" name=\"family\">\n      <string>sans-serif</string></test>\n    <edit name=\"family\" mode=\"prepend\" binding=\"same\">\n      <string>Noto Sans</string>\n    </edit>\n  </match>\n\n  <!-- Default serif fonts -->\n  <match target=\"pattern\">\n    <test qual=\"any\" name=\"family\">\n      <string>serif</string>\n    </test>\n    <edit name=\"family\" mode=\"prepend\" binding=\"same\">\n      <string>Noto Serif</string>\n    </edit>\n  </match>\n\n  <!-- Fallback fonts preference order -->\n  <alias>\n    <family>sans-serif</family>\n    <prefer>\n      <family>Noto Sans</family>\n      <family>Noto Sans CJK SC</family>\n      <family>Noto Sans CJK TC</family>\n      <family>Noto Sans CJK JP</family>\n      <family>Noto Sans CJK KR</family>\n      <family>Noto Color Emoji</family>\n      <family>Noto Emoji</family>\n    </prefer>\n  </alias>\n  <alias>\n    <family>serif</family>\n    <prefer>\n      <family>Noto Serif</family>\n      <family>Noto Serif CJK SC</family>\n      <family>Noto Serif CJK TC</family>\n      <family>Noto Serif CJK JP</family>\n      <family>Noto Serif CJK KR</family>\n      <family>Noto Color Emoji</family>\n      <family>Noto Emoji</family>\n    </prefer>\n  </alias>\n  <alias>\n    <family>monospace</family>\n    <prefer>\n      <family>Noto Sans Mono</family>\n      <family>Noto Color Emoji</family>\n      <family>Noto Emoji</family>\n    </prefer>\n  </alias>\n\n</fontconfig>\n```\n然后刷新字体缓存：\n```shell\n$ fc-cache -fv\n```\n\n#### 桌面字体设置\n* 在`菜单->首选项->外观->字体`中可以找到桌面相关字体配置，这里将这些字体（除等宽）都改为`Noto Sans CJK SC Regular`，等宽字体改为`Noto Sans Mono Regular`，字体大小设置为10左右，当然这些根据个人的电脑的效果调整。\n* 在渲染中的细节中，关闭分辨率的自动检测，然后手动设置DPI，我的电脑是1080的，故设置为124左右即可（其他屏幕可视效果调整）；微调设置为完全，其他的可以保持不动。\n\n#### Qt应用字体设置\n* 在`菜单->首选项->Qt5设置`中，将字体设置为`Noto Sans CJK`系列，根据效果调整大小。\n\n#### 浏览器字体设置\n浏览器页面的字体不受桌面字体设置的影响，桌面字体仅仅只能改变浏览器顶部选项卡以及菜单的字体大小，网页的字体还需要在浏览器中单独设置，这里以chrome为例，其他浏览器有类似设置。打开chrome设置页面，找到自定义字体，然后打开高级字体设置。浏览器的配置经过反复的尝试折腾，最终配置如下:\n![img][1]\n以上为`Default`的配置，还需要配置下`Simplified Han`，在Script中找到并修改成一样即可。如果有emoji显示不正常的问题，需检查[字体配置](#配置字体)是否正确，最后看下我的配置效果：\n![img][2]\n![img][3]\n至于中文字体的效果，可根据自己的喜好选择Noto系列或者文泉驿字体，或者其他好看的中文字体。\n\n#### 其他\n至于其他应用（如：IDEA，VS Code等等），内部都有相应设置字体的地方，按自己的喜好设置字体及大小即可。\n\n\n[1]: /uploads/work-on-linux/font-config.png\n[2]: /uploads/work-on-linux/font-config-effects1.png\n[3]: /uploads/work-on-linux/font-config-effects2.png","tags":["linux"],"categories":["misc"]},{"title":"在Linux下进行开发工作（二）","url":"%2F2018%2F10%2F18%2Fwork-on-linux-part-two%2F","content":"\n{% post_link work-on-linux-part-one %}中记录了Manjaro的安装过程以及源设置等等，这一篇主要记录下常用软件的安装等等。Manjaro固然非常的方便，各种开发工具一条命令就可以安装好，但有些Windows常用软件Linux上也没有，有的可以使用Linux上的替代品，不过还是有少许软件不可避免的要使用（如微信，QQ等），这会给我们的工作带来了不少的麻烦，刚从Windows转Linux会有诸多的不习惯，不过都还好，我们总是有各种各样的办法来折腾Linux来适合我们用来做日常的开发桌面。还是那句话，如果没准备好用Linux作为日常开发桌面，千万不要尝试 : )。\n<!-- more  -->\n\n#### 输入法\n毕竟日常还是使用中文，中文输入法是必须得安装的，Linux下的输入框架常用的有`fcitx`和`ibus`，我选用的是[fcitx][1]：\n* 安装fcitx\n    ```shell\n    $ sudo pacman -S fcitx fcitx-configtool \n    ```\n* 安装输入法引擎\n    fcitx默认自带了中文输入引擎，其他选择就比较多了，（比如国内常用的sougou拼音），我选择的是[Rime][2]，配上一个`fcitx-skin-material`用来非常不错。不过Rime默认是繁体输入，如果要改为默认简体，需新增一个自定义配置文件`$HOME/.config/fcitx/rime/\n    luna_pinyin.custom.yaml`：\n    ```yml\n    patch:\n    \"menu/page_size\": 9\n    switches:                   # 注意缩进\n        - name: ascii_mode\n        reset: 0                # reset 0 的作用是当从其他输入法切换到本输入法重设为指定状态\n        states: [ 中文, 西文 ]   # 选择输入方案后通常需要立即输入中文，故重设 ascii_mode = 0\n        - name: full_shape\n        states: [ 半角, 全角 ]   # 而全／半角则可沿用之前方案的用法。\n        - name: simplification\n        reset: 1                # 增加这一行：默认启用「繁→簡」转换。\n        states: [ 漢字, 汉字 ]\n    ```\n    这里面还包括候选字数，全/半角等配置。\n* 安装输入法模组\n    要在桌面上使用（包括浏览器，应用等等），还需要安装输入法模组，尽可能的安装完全：\n    ```shell\n    $ sudo pacman -S fcitx-gtk2 fcitx-gtk3 fcitx-qt4 fcitx-qt5\n    ```\n* 添加配置\n    在`$HOME/.xprofile`中添加如下配置\n    ```text\n    export GTK_IM_MODULE=fcitx\n    export QT_IM_MODULE=fcitx\n    export XMODIFIERS=@im=fcitx\n    ```\n最后重启电脑，既可以使用输入法了，关于快捷键和字体大小，可在fcitx config GUI里面配置。至此，输入法基本上就搞定了。\n\n#### 微信\n日常中微信使用的频率比较高，不可避免的要安装，一般有几种解决方案：\n* [electronic-wechat][3]\n使用的是微信web版，然后用electronic封装的，作者似乎以及停更了，安装后体验了下，弃了。\n* [weweChat][4]\n界面做得比较好看，和electronic-wechat使用同样的原理，没体验过。\n* [deepin-wechat][5]\n使用deepin自己定制的[wine][6]，安装后，不知道为什么我电脑上问题挺多（比如不能贴图），遂弃之。\n\n体验过这么多之后，最后还是决定使用wine版本的，不过是自己进行配置。在github上找到一个专门针对国内软件的wine脚本[winetricks-zh][7]，会自动安装一些依赖，最后尝试下来这个版本体验最好，除了不能截图（当然有替代方案，[shutter][8]），其他基本和Windows上没太大差别。\n* 安装wine及相关依赖\n    ```shell\n    $ sudo pacman -S wine wine-mono wine_gecko\n    ```\n* 使用winetricks-zh安装微信\n    作者有较长时间未更新了，目前微信官网的微信已更新，会导致文件校验失败，不过只需要把脚本中的hash值改一下即可（文件为在`winetricks-zh/verb/wechat.verb`），下载官网最新安装包，然后计算sha256:\n    ```shell\n    $ sha256sum WeChatSetup.exe\n    ```\n    最后将hash值替换为此hash值即可，后续就会自动安装一些依赖。\n* 配置\n    安装完后可以直接打开使用，不过由于屏幕适配以及字体问题，可能会导致乱码，字体小的问题，因此我们还需要修改些配置才能正常使用。\n    - 字体安\n    需要将`微软雅黑`和`新宋`字体复制到`$HOME/.local/share/fonts`下，并刷新字体缓存：\n    ```shell\n    $ fc-cache -fv\n    ```\n    - 修改`$HOME/.wine/system.reg`\n    找到`LogPixels`，将值修改为80（根据自己的屏幕调整）\n    - 修改`$HOME/.wine/driver_c/windows/win.ini`\n    在文件尾新增：\n    ```text\n    [Desktop]\n    menufontsize=13\n    messagefontsize=13\n    statusfontsize=13\n    IconTitleSize=13\n    ```\n    - 新增`$HOME/.wine/zh.reg`\n    在文件中添加以下参数：\n    ```text\n    REGEDIT4\n\n    [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]\n\n    \"Arial\"=\"simsun\"\n    \"Arial CE,238\"=\"simsun\"\n    \"Arial CYR,204\"=\"simsun\"\n    \"Arial Greek,161\"=\"simsun\"\n    \"Arial TUR,162\"=\"simsun\"\n    \"Courier New\"=\"simsun\"\n    \"Courier New CE,238\"=\"simsun\"\n    \"Courier New CYR,204\"=\"simsun\"\n    \"Courier New Greek,161\"=\"simsun\"\n    \"Courier New TUR,162\"=\"simsun\"\n    \"FixedSys\"=\"simsun\"\n    \"Helv\"=\"simsun\"\n    \"Helvetica\"=\"simsun\"\n    \"MS Sans Serif\"=\"simsun\"\n    \"MS Shell Dlg\"=\"simsun\"\n    \"MS Shell Dlg 2\"=\"simsun\"\n    \"System\"=\"simsun\"\n    \"Tahoma\"=\"simsun\"\n    \"Times\"=\"simsun\"\n    \"Times New Roman CE,238\"=\"simsun\"\n    \"Times New Roman CYR,204\"=\"simsun\"\n    \"Times New Roman Greek,161\"=\"simsun\"\n    \"Times New Roman TUR,162\"=\"simsun\"\n    \"Tms Rmn\"=\"simsun\"\n    ```\n重新打开微信，应该就没什么问题了。关于快捷键问题，Linux下无法直接使用微信中的快捷键（其实是没有焦点，如果打开微信的设置页面，再使用打开快捷键，发现还是有用的，当然这非常不方便），最后找了个办法，在系统快捷键中，添加一个快捷键来打开微信即可，命令使用wine来打开：\n```text\nenv WINEPREFIX=\"/home/cooler/.wine\" wine \"/home/cooler/.wine/drive_c/Program Files/Tencent/WeChat/WeChat.exe\"\n```\n这样就可以使用快捷键打开微信，不过不能关闭，只能使用`Esc`来关闭，不过这点小问题不影响使用。至于其他软件，可以参考`winetricks-zh`。\n\n#### 开发软件\n一般开发软件都有Linux版本的，除非是系统特有的软件（如Windows的visual studio等等），这种就没办法了，只能放弃使用Linux了。\n\n#### 截图软件\nLinux下首推[shutter][8]，功能已经非常完善了，在系统快捷键中新增一个，命令如下：\n```text\nshutter -s\n```\n然后配合微信，QQ等使用，直接粘贴到对话框中即可。\n\n#### 办公软件\nWindows下办公软件莫过于Office全家桶，但Linux下就没这么好的办公软件了，替代品为[WPS Office][9]和[Libre Office][10]，wps用起来比较接近MS Office，这个看个人喜好选择。\n\n#### 其他\n* 制图软件[GIMP][11]\n* 思维导图[XMind][12]\n* PDF阅读使用自带的`Atril Document Viewer`就可以了\n* 视频播放软件[VLC][13]。\n* 邮件客户端[Evolution][14]\n* ......\n\n[1]: https://wiki.archlinux.org/index.php/Fcitx\n[2]: https://wiki.archlinux.org/index.php/Rime_IME\n[3]: https://github.com/geeeeeeeeek/electronic-wechat\n[4]: https://github.com/trazyn/weweChat\n[5]: https://aur.archlinux.org/packages/deepin-wechat/\n[6]: https://www.winehq.org/\n[7]: https://github.com/hillwoodroc/winetricks-zh\n[8]: http://shutter-project.org/\n[9]: https://www.wps.com/\n[10]: https://www.libreoffice.org/\n[11]: https://www.gimp.org/\n[12]: https://www.xmind.net/\n[13]: https://www.videolan.org/vlc/\n[14]: https://wiki.gnome.org/Apps/Evolution","tags":["linux"],"categories":["misc"]},{"title":"在Linux下进行开发工作（一）","url":"%2F2018%2F10%2F17%2Fwork-on-linux-part-one%2F","content":"\n之前在做嵌入式开发时，经常会使用到Linux，但都是使用的虚拟机来安装Linux，然后在Windows上通过ssh连接，使用的命令行方式，并未使用Linux当桌面。后来做Android开发后，基本是在Windows下进行开发工作的，部分Linux下的命令工具可以通过[mingw][1]来使用，但终究还是不如直接在Linux下来得方便。年中的时候，入手了一台新本，开始折腾起来Linux，选择的是[Manjaro][2]发行版的Mate Desktop，几个桌面版本尝试后，最终选择了Mate。Manjaro是[Arch Linux][3]衍生版，但是简化了安装过程，几乎是一键安装，省去了Arch Linux的繁琐配置，但却拥有Arch Linux同样丰富的软件库。折腾过程中遇到不少问题，都通过各种google解决了，如果没准备好用Linux作为日常开发桌面，千万不要尝试 : )。\n<!-- more -->\n\n#### 安装Manjaro\n在[Manjaro官网][2]找自己比较喜欢的桌面下载镜像文件，准备一个空的U盘（后面会被格式化），Windows下使用[rufus][4]来创建USB启动盘。将镜像文件烧写到U盘（注意：rufus中需选择DD模式），电脑上选择U盘启动，就会进入到Manjaro的安装界面，选择对应的语言，驱动等等，然后启动可以进入到Manjaro系统进行体验，直接进入安装步骤，都是些个性化设置。在分区的时候需要注意，选择手动分区，如果想要安装双系统，需要找到Windows的`efi`分区（一般是一个100M的FAT32分区），然后挂载`/boot/efi`（不要选择格式化），其他分区按需分配即可。我的分区结构：\n* `/`分区（必须有此分区） --- 50G\n* `/boot`分区 --- 512M\n* `/var`分区（pacman会缓存安装包） --- 30G\n* `/swap`分区 --- 4G\n* `/home`分区 --- 余下的所有空间\n最后到安装等待界面，待安装完成重新启动应该会有个GRUB bootloader了。但我的电脑死活没看到grub，最后看到[官网安装教程][5]才知道，有些电脑装双系统后，GRUB会显示不出来，解决方案就是安装[rEFInd][6]，这步操作需要重启电脑，通过USB启动，这里会显示出刚刚安装的系统（不要选择安装在U盘的那个系统，其实就是通过U盘来做引导），选择进入，然后在Terminal中安装rEFInd：\n```shell\n$ sudo pacman -S refind-efi\n```\n安装完后重启，这次就看到rEFInd界面了，在这里可以选择启动Windows或者Manjaro。\n\n#### 更新系统\n首次进入系统，第一件事情就是更新系统，首先我们需要做的是设置国内的镜像源，这样下载的速度会快些。\n* 配置镜像源\n    ```\n    $ sudo pacman-mirrors -i -c China -m rank\n    ```\n    这条命令会获取中国的镜像源并进行排序，最后生成一个镜像列表，然后选择需要的源地址。\n* 设置archlinux源\n    打开`/etc/pacman.conf`，并添加一下内容\n    ```text\n    [archlinuxcn]\n    SigLevel = Optional TrustedOnly\n    Server = http://repo.archlinuxcn.org/$arch\n    ```\n    然后根据上面的配置，生成一个新的`mirrolist`：\n    ```shell\n    $ sudo pacman-mirrors -g\n    ```\n* 更新\n    镜像里面设置完成后，就进行系统的全面升级:\n    ```shell\n    $ sudo pacman -Syyu\n    ```\n    由于使用了archlinuxcn的镜像，还需要安装`archlinuxcn-keyring`，才能安装镜像上的软件：\n    ```shell\n    $ sudo pacman -S archlinuxcn-keyring\n    ```\n平时使用中还会安装一些非官方软件（也就是AUR包），这需要安装一个额外的工具，一般安装的`yaourt`，当然还有其他很多[AUR工具][7]，可以根据喜好自行选择。如果不习惯使用命令行安装，也可以使用pacman的GUI，在首选项中可以设置打开AUR，然后搜索时候选择AUR即可安装相应的AUR包。\n\n\n[1]: http://www.mingw.org/\n[2]: https://manjaro.org/get-manjaro/\n[3]: https://www.archlinux.org/\n[4]: http://rufus.ie/\n[5]: https://wiki.manjaro.org/index.php?title=UEFI_-_Install_Guide\n[6]: http://www.rodsbooks.com/refind/index.html\n[7]: https://wiki.archlinux.org/index.php/AUR_helpers","tags":["linux"],"categories":["misc"]},{"title":"从Jekyll迁移到Hexo","url":"%2F2018%2F10%2F16%2Fjekyll-to-hexo%2F","content":"\n自上次更新博客以来已超过2年，其一是工作太忙，其二主要是因为自己太懒，不过这其间学习非常多的新知识。最近新增了几个项目之后，发现已经太久没更新博客，同时感觉jekyll用起来还是不够舒服，经过一番google，找到[hexo][1]，hexo原理和jekyll差不多，但是代码块高亮直接使用的markdown的语法，无需像jekyll那样的高亮语法，又找了个简洁的主题[hexo-theme-next][2],于是折腾起hexo来，至于为什么不去折腾hugo，主要是因为找了半天主题没找到满意的，遂放弃了。hexo的使用可以参见[官网][3]的步骤，非常的详细，大致记录一下迁移过程。\n<!-- more -->\n#### 项目初始化\n```shell\n$ npm install -g hexo-cli\n$ hexo init coolerfall.github.io\n$ cd coolerfall.github.io && npm install\n```\n\n#### 配置\n完全配置文件可参考官网的文档，一般来说需要改下作者信息，描述等等，默认是使用landscape主题，我这里使用的是[hexo-theme-next][2]，参见文档将代码加入hexo目录下的`themes`下，修改根目录`_config.yml`中的`theme`为`next`即可，next主题完全配置参见官网文档，需要注意的是next默认没有生成`tags`和`categories`的index页面，需要自己手动生成：\n```shell\n$ hexo new page tags\n$ hexo new page categories\n```\n生成的文件在`_posts`下的`tags`和`categories`中，将`type`分别改为`tags`和`categories`即可，后面自动生成。配置好后，可以简单运行下看看效果：\n```shell\n$ hexo serve\n```\n\n#### 迁移\n由于之前用的是Jekyll，post文章的格式为`:year-:month-:day-:title.md`，因此hexo也采用同样的格式即可，只需将`new_post_name`改为这种格式。将Jekyll目录下的`_posts`中文章全部copy到hexo目录下的`source/_posts`中，由于文章是Markdown格式，所以基本没有太大改动，我之前使用了Jekyll的一个高亮插件，写法与Markdown有所区别，只需把这些写法改为Markdown的写法即可，然后运行可看到效果。关于文章长度太长，需显示`阅读全文`，有两种方式：\n* 自动截取\n需修改`next`主题配置文件中`auto_excerpt`为true，以及截取开始长度（但这种方式不推荐）。\n* 手动添加\n只需要在每篇post中需要截取的地方加入`<!-- more -->`即可。\n\n#### 部署\n最后部署至github，hexo有多种部署方式，可部署至`Git`，`Heroku`，`Netlify`等等，都有相应部署工具。这里使用`hexo-deployer-git`，需在根目录下加入\n```shell\n$ npm install hexo-deployer-git --save\n```\n在根目录配置文件中的`deploy`中加入相关配置，然后执行部署\n```shell\n$ hexo g -d\n```\n注意，Hexo与Jekyll有区别，github默认在服务器上生成并部署，而Hexo需要我们在本地生成好静态文件后再上传，因此，需要分两个分支来存放代码，master分支放静态文件，另起一个分支（如：source）来存放源码，这里就需要在deploy中加入这两个分支的操作：\n```yml\ndeploy:\n  - type: git\n    repo: git@github.com:you/your.github.io.git\n    branch: [master]\n  - type: git\n    repo: git@github.com:you/anothergit.git\n    branch: [master]\n    extend_dirs: /\n    ignore_hidden: false\n    ignore_pattern:\n        public: .\n```\n至此，博客从Jekll成功迁移到了Hexo。\n\n[1]: https://github.com/hexojs/hexo\n[2]: https://github.com/theme-next/hexo-theme-next\n[3]: https://hexo.io/zh-cn/docs/","tags":["hexo"],"categories":["misc"]},{"title":"使用UrlQuerySanitizer来处理url","url":"%2F2016%2F03%2F30%2Furl-query-sanitizer%2F","content":"\n网上对于UrlQuerySanitizer的资料比较少，这个是Android提供的一个用来处理url的API。由于项目的需要，需要对url的query参数进行排序，因此需要解析url并处理query参数。\n<!-- more -->\n最初的方法是使用Uri：\n```java\npublic void parseUrl(String url) {\n\tUri uri = Uri.parse(url);\n\tSet<String> query = uri.getQueryParameterNames();\n\tif (!query.isEmpty()) {\n\t\tTreeSet<String> treeQuery = new TreeSet<>(query);\n\t\tfor (String key : treeQuery) {\n\t\t\tString value = uri.getQueryParameter(key);\n\t\t}\n\t}\n}\n```\n通过这样的方式就可以解析url，并获取到各个query参数。但后来发现Uri不能处理一些特殊字符，比如`#`，Uri会截断`#`以后的内容，这样就不能满足开发需求。经过各种google，最后发现了一个UrlQuerySanitizer的API：\n```java\npublic void parseUrl(String url) {\n\tUrlQuerySanitizer sanitizer = new UrlQuerySanitizer();\n\tsanitizer.setAllowUnregisteredParamaters(true);\n\tsanitizer.setUnregisteredParameterValueSanitizer(UrlQuerySanitizer.getAllButNulLegal());\n\tsanitizer.parseUrl(url);\n\tfinal Set<String> query = sanitizer.getParameterSet();\n\tif (!query.isEmpty()) {\n\t\tTreeSet<String> treeQuery = new TreeSet<>(query);\n\t\tfor (String key : treeQuery) {\n\t\t\tString value = sanitizer.getValue(key);\n\t\t}\n\t}\n}\n```\n首先要使用`setAllowUnregisteredParamaters`让其支持特殊字符，然后使用`setUnregisteredParameterValueSanitizer`来设置支持哪些特殊字符，UrlQuerySanitizer提供了集中默认的ValueSanitizer：\n```java\n/**\n * Return a value sanitizer that does not allow any special characters,\n * and also does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAllIllegal() {\n\treturn sAllIllegal;\n}\n\n/**\n * Return a value sanitizer that allows everything except Nul ('\\0')\n * characters. Script URLs are allowed.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAllButNulLegal() {\n\treturn sAllButNulLegal;\n}\n/**\n * Return a value sanitizer that allows everything except Nul ('\\0')\n * characters, space (' '), and other whitespace characters.\n * Script URLs are allowed.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAllButWhitespaceLegal() {\n\treturn sAllButWhitespaceLegal;\n}\n/**\n * Return a value sanitizer that allows all the characters used by\n * encoded URLs. Does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getUrlLegal() {\n\treturn sURLLegal;\n}\n/**\n * Return a value sanitizer that allows all the characters used by\n * encoded URLs and allows spaces, which are not technically legal\n * in encoded URLs, but commonly appear anyway.\n * Does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getUrlAndSpaceLegal() {\n\treturn sUrlAndSpaceLegal;\n}\n/**\n * Return a value sanitizer that does not allow any special characters\n * except ampersand ('&'). Does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAmpLegal() {\n\treturn sAmpLegal;\n}\n/**\n * Return a value sanitizer that does not allow any special characters\n * except ampersand ('&') and space (' '). Does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAmpAndSpaceLegal() {\n\treturn sAmpAndSpaceLegal;\n}\n/**\n * Return a value sanitizer that does not allow any special characters\n * except space (' '). Does not allow script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getSpaceLegal() {\n\treturn sSpaceLegal;\n}\n/**\n * Return a value sanitizer that allows any special characters\n * except angle brackets ('<' and '>') and Nul ('\\0').\n * Allows script URLs.\n * @return a value sanitizer\n */\npublic static final ValueSanitizer getAllButNulAndAngleBracketsLegal() {\n\treturn sAllButNulAndAngleBracketsLegal;\n}\n```\n每种ValueSanitizer都对应过滤哪些字符，被过滤掉的特殊字符会被替换成_或者空格。\n如果默认的ValueSanitizer不能满足开发需求，还可以自己构造ValueSanitizer：\n```java\npublic void parseUrl(String url) {\n\t.....\n\tValueSanitizer sanitizer = new UrlQuerySanitizer.IllegalCharacterValueSanitizer(UrlQuerySanitizer.IllegalCharacterValueSanitizer.ALL_OK);\n\tsetUnregisteredParameterValueSanitizer(sanitizer);\n\t.....\n}\n```\nUrlQuerySanitizer也可以通过key来获取相应的value，比如给一个url：http://coolerfall.com?name=vincent：\n```java\npublic void parseUrl(String url) {\n\tUrlQuerySanitizer sanitizer = new UrlQuerySanitizer();\n\tsanitizer.setAllowUnregisteredParamaters(true);\n\tsanitizer.setUnregisteredParameterValueSanitizer(UrlQuerySanitizer.getAllButNulLegal());\n\tsanitizer.parseUrl(url);\n\tString name = sanitizer.getValue(\"name\");\n}\n```\nUrlQuerySanitizer还可以只解析query参数，比如：name=vincent&article=first：\n```java\npublic void parseUrl(String query) {\n\tUrlQuerySanitizer sanitizer = new UrlQuerySanitizer();\n\tsanitizer.setAllowUnregisteredParamaters(true);\n\tsanitizer.setUnregisteredParameterValueSanitizer(UrlQuerySanitizer.getAllButNulLegal());\n\tsanitizer.parseQuery(query);\n\tString name = sanitizer.getValue(\"name\");\n\t.....\n}\n```\n以上就是UrlQuerySanitizer大致用法，用来解析处理url非常的方便。","tags":["sanitizer"],"categories":["android"]},{"title":"使用MediaSessionCompat来实现Media Button的监听","url":"%2F2016%2F01%2F06%2Fmedia-session-compat%2F","content":"\n在API21之前，如果想实现线控，则只需要使用:\n```java\nAudioManager.reregisterMediaButtonEventReceiver(ComponentName eventReceiver)\n```\n即可，但是最近更新SDK之后发现这个API已经废弃掉了，推荐使用MediaSession来代替。\n<!-- more -->\nAPI21之前的实现可以参考[这篇文章][1]，但是MediaSession是在新的api中加入的，我们可以使用android.support.v4.media.session.MediaSessionCompat：\n```java\n/**\n * Creates a new session.\n *\n * @param context The context.\n * @param tag A short name for debugging purposes.\n * @param mediaButtonEventReceiver The component name for your receiver.\n *            If null, this will attempt to find an appropriate\n *            {@link BroadcastReceiver} that handles\n *            {@link Intent#ACTION_MEDIA_BUTTON} from your manifest.\n *            A receiver is required to support platform versions earlier\n *            than {@link android.os.Build.VERSION_CODES#LOLLIPOP}.\n * @param mbrIntent The PendingIntent for your receiver component that\n *            handles media button events. This is optional and will be used\n *            on {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} and\n *            later instead of the component name.\n */\npublic MediaSessionCompat(Context context, String tag, ComponentName mediaButtonEventReceiver,\n            PendingIntent mbrIntent) {\n```\nMediaSessionCompat的构造函数一共有四个参数，我们这里简单实现Media Button的监听，只需要context和mediaButtonEventReceiver即可，tag用于调试，mbrIntent设置为null即可。首先和API21之前一样实现了一个MediaButtonReceiver：\n```java\npublic class MediaButtonReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\tif (!Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {\n\t\t\treturn;\n\t\t}\n\n\t\tKeyEvent event = intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);\n\t\tif (event == null || event.getAction() != KeyEvent.ACTION_UP) {\n\t\t\treturn;\n\t\t}\n\n\t\t// do something\n\t}\n}\n```\n接下来我们要做的就是new一个MediaSessionCompat：\n```java\npublic class PlayerService extends Service {\n\tprivate MediaSessionCompat mMediaSession;\n\t\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\n\t\tComponentName mbr = new ComponentName(getPackageName(), MediaButtonReceiver.class.getName());\n\t\tmMediaSession = new MediaSessionCompat(this, \"mbr\", mbr, null);\n\t\t/* set flags to handle media buttons */\n\t\tmMediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | \n\t\t\tMediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);\n\n\t\t/* this is need after Lolipop */\n\t\tmMediaSession.setCallback(new MediaSessionCompat.Callback() {\n\t\t\t@Override\n\t\t\tpublic boolean onMediaButtonEvent(Intent intent) {\n\t\t\t\tif (!Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {\n\t\t\t\t\treturn super.onMediaButtonEvent(intent);\n\t\t\t\t}\n\n\t\t\t\tKeyEvent event = intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);\n\t\t\t\tif (event == null || event.getAction() != KeyEvent.ACTION_UP) {\n\t\t\t\t\treturn super.onMediaButtonEvent(intent);\n\t\t\t\t}\n\n\t\t\t\t// do something\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t/* to make sure the media session is active */\n\t\tif (!mMediaSession.isActive()) {\n\t\t\tmMediaSession.setActive(true);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onDestroy() {\n\t\tmMediaSession.release();\n\t}\n}\n```\n其他的和API21之前一样，需要在manifest中注册这个MediaButtonReceiver\n```java\n<receiver android:name=\"com.coolerfall.managers.receivers.MediaButtonReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MEDIA_BUTTON\"/>\n    </intent-filter>\n</receiver>\n```\n这样就可以实现和API21之前的监听效果了。\n\nPS: API21之前MediaButtonReceiver是必须的；API21之后MediaSessionCompat.setCallback是必须的，因为MediaSessionCompatAPI21之后通过callback来处理media button。\n\n[1]: http://blog.csdn.net/qinjuning/article/details/6938436","tags":["media"],"categories":["android"]},{"title":"Error: The output jar is empty. Did you specify the proper '-keep' options","url":"%2F2015%2F11%2F20%2Fproguard-shrink-error%2F","content":"\n最近在写个小工具混淆Android lib包，用到了proguard命令行的方式，结果出现`Error: The output jar is empty. Did you specify the proper '-keep' options`的错误。\"出现这个错误是因为我这里混淆的lib包里面所有方法都没有调用，所以输入类全被压缩移除，导致没有输出。解决这个问题很简单，只需要加上`-dontshrink`就可以了。","tags":["proguard"],"categories":["android"]},{"title":"Android AppWidget中实现动画效果","url":"%2F2015%2F07%2F27%2Fapp-widget-animation%2F","content":"\n最近在写AppWidget的时候，想实现一个淡入的动画效果，由于AppWidget只支持几种view并且没有提供实现动画的方法，折腾了很久发现只有使用LayoutAnimation可以勉强实现动画效果。\n<!-- more -->\n这里就拿淡入动画作为例子。首先在`res/anim`中新建一个动画`fade_in.xml`：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       android:duration=\"1200\"\n       android:fromAlpha=\"0.0\"\n       android:interpolator=\"@android:anim/accelerate_interpolator\"\n       android:toAlpha=\"0.8\"/>\n```\n然后再新建一个layoutAnimation，`widget_fade_in.xml`：\n```xml\n<layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                 android:animation=\"@anim/fade_in\"/>\n```\n动画效果准备好后，接下来就是在AppWidget布局中使用了。比如AppWidget的布局，`widget_layout.xml`如下：\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:background=\"@color/widget_bg\">\n\n    <RelativeLayout\n        android:id=\"@+id/widget_layout_iv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layoutAnimation=\"@anim/widget_fade_in\">\n\n        <ImageView\n            android:id=\"@+id/widget_iv\"\n            android:layout_width=\"100.0dip\"\n            android:layout_height=\"100.0dip\"\n            android:layout_centerInParent=\"true\"/>\n\n    </RelativeLayout>\n\n    <TextView\n        android:id=\"@+id/widget_tv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/app_name\">\n    </TextView>\n\n</LinearLayout>\n```\n要让ImageView实现淡入动画，需要将其单独加入到一个layout中，然后在layout中加入`android:layoutAnimation=\"@anim/widget_fade_in\"`。这样ImageView所在的layout就有动画效果了，不过这个动画效果只会在AppWidget第一次加载的时候有，如果想每隔一段时间去切换，就需要让AppWidget不断的实现重新加载的过程，需要使用到RemoteViews的removeAllViews和addView方法，这两个方法可以让AppWidget的layout刷新来实现重复动画的效果。再新建一个layout文件`widget_image.xml`:\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/widget_layout_iv\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:layoutAnimation=\"@anim/widget_fade_in\">\n\n    <ImageView\n        android:id=\"@+id/widget_iv\"\n        android:layout_width=\"100.0dip\"\n        android:layout_height=\"100.0dip\"\n        android:layout_centerInParent=\"true\"/>\n\n</RelativeLayout>\n```\n这里面的内容保持和`widget_layout.xml`中要实现动画的layout一致就行了。\n最后需要在AppWidgetProvider中使用removeAllViews和addView方法：\n```java\npublic class ExampleWidget extends AppWidgetProvider {\n\t@Override\n\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n\t\tupdateWidget(context, appWidgetManager, appWidgetIds);\n\t}\n\n\tpublic static void updateWidget(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n\t\tString pkgName = context.getPackageName();\n\t\tRemoteViews views = new RemoteViews(pkgName, R.layout.widget_layout);\n\t\tRemoteViews subView = new RemoteViews(pkgName, R.layout.widget_image);\n\t\tviews.removeAllViews(R.id.widget_layout);\n\t\tviews.addView(R.id.widget_layout, subView);\n\t}\n}\n```\n最后就是在Activity或者Service中，在需要更新的时候调用`updateWidget`就有动画效果了。","tags":["animation"],"categories":["android"]},{"title":"Java中计算字符串以及文件的hash值","url":"%2F2015%2F07%2F24%2Fjava-hash%2F","content":"\nAndroid开发中常常会使用到hash值，字符串的hash用的比较多，一般用于字段、存储的key等等，文件的hash一般用于校验文件的正确性，记录下最简单的方式。\n <!-- more -->\n计算字符串的hash值，网上也有其他的计算方法，这里给出一个相对简洁的方法：\n```java\npublic static String md5(String origin) {\n\ttry {\n\t\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n\t\tmd.update(origin.getBytes(\"UTF-8\"));\n\t\tBigInteger bi = new BigInteger(1, md.digest());\n\n\t\treturn bi.toString(16);\n\t} catch (Exception e) {\n\t\treturn \"\";\n\t}\n}\n```\n注意要把字符串用utf-8的方式获取byte，否则会导致不用语言之间得出的结果不一样（比如php或go）。\n计算文件的hash值略麻烦一点：\n```java\npublic static String fileHash(String filePath) {\n\tFile file = new File(filePath);\n\tif (file == null || !file.exists()) {\n\t\treturn NULL;\n\t}\n\n\tString result = NULL;\n\tFileInputStream fis = null;\n\n\ttry {\n\t\tfis = new FileInputStream(file);\n\t\tMappedByteBuffer mbf = fis.getChannel().map(\n\t\t\t\tFileChannel.MapMode.READ_ONLY, 0, file.length());\n\t\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n\t\tmd.update(mbf);\n\t\tBigInteger bi = new BigInteger(1, md.digest());\n\t\tresult = bi.toString(16);\n\t} catch (Exception e) {\n\t\treturn NULL;\n\t} finally {\n\t\tif (fis != null) {\n\t\t\ttry {\n\t\t\t\tfis.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t/* ignore */\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n```\n如果文件较大，这个计算过程可能会比较长。\n\nsha1和sha256的计算方法就很类似了，只需要将`MessageDigest.getInstance(\"MD5\")`换一下就可以用了。go版本的hash计算请查看[go-hash][1]。\n\n[1]: http://coolerfall.com/go/golang-hash","tags":["hash"],"categories":["Android"]},{"title":"Linux c语言一些字符串操作函数的实现","url":"%2F2015%2F07%2F22%2Flinux-c-string-operation%2F","content":"\nc语言对字符串的操作函数有很多都没有实现，比如java中的trim、indexOf、substring等等，于是就动手实现了几个字符串操作函数，以备以后开发中使用。\n<!-- more -->\n#### 1.trim函数（去掉字符串首尾空格）\n```c\n/**\n * Remove space from string at the beginning and end.\n *\n * @param src pointer to source string\n */\nvoid trim(char *src)\n{\n\tint i;\n\tint len = strlen(src);\n\tint start = 0, end = len - 1;\n\n\twhile (start < end && src[start] <= ' ' && src[start] != 0)\n\t{\n\t\tstart ++;\n\t}\n\n\twhile (end >= start && src[end] <= ' ' && src[end] != 0)\n\t{\n\t\tend --;\n\t}\n\n\tmemmove(src, src + start, end - start + 1);\n\tsrc[end - start + 1] = '\\0';\n}\n```\n#### 2.index_of函数（获得某个字符串在另一个字符串中第一次出现时的位置）\n```c\n/**\n * To get the index when sub string first appear in src.\n *\n * @param src src string\n * @param sub the string to search\n * @return    the index of substring in source string, \n *            otherwise return -1 if not exists\n */\nint index_of(const char *src, const char *sub)\n{\n\tchar *result = strstr(src, sub);\n\n\treturn result ? strlen(src) - strlen(result) : -1;\n}\n```\n#### 3.last_index_of函数（获得某个字符串在另一个字符串中最后一次出现时的位置）\n```c\n/**\n * To get the index when need string last appear in src.\n *\n * @param src  src string\n * @param need the string to search\n * @return     the index of substring in source string, \n *             otherwise return -1 if not exists\n */\nint last_index_of(const char *src, const char *need)\n{\n\tint i;\n\tconst char *p = src + strlen(src);\n\tsize_t len = strlen(need);\n\tchar *buf;\n\n\tfor(i = 0; i < strlen(src); i ++)\n\t{\n\t\tbuf = strchr(p --, *need);\n\t\tif (!buf)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncmp(buf, need, len) == 0)\n\t\t{\n\t\t\treturn strlen(src) - strlen((char *)buf);\n\t\t}\n\t}\n\n\treturn -1;\n}\n```\n#### 4.substring函数（截取字符串）\n```c\n/**\n * Get sub string from source string.\n *\n * @param dest  dest poniter to save string\n * @param src   source string poniter\n * @param start the start index\n * @param end   the end index\n */\nvoid substring(char *dest, const char *src, int start, int end)\n{\n\tint i = start;\n\n\tif (start > strlen(src))\n\t{\n\t\treturn;\n\t}\n\n\tif (end > strlen(src))\n\t{\n\t\tend = strlen(src);\n\t}\n\n\twhile (i < end)\n\t{\n\t\tdest[i - start] = src[i];\n\t\ti ++;\n\t}\n\n\tdest[i - start] = '\\0';\n}\n```\n#### 5.starts_with函数（检测字符串是否以某个字符串开头）\n```c\n/**\n * To check if the string start with specified string.\n *\n * @param  src    source string pointer\n * @param  prefix prefix string poniter\n * @return        ture if start with specified string, otherwise return false\n */\nbool starts_with(const char *src, const char *prefix)\n{\n\tint len = strlen(prefix);\n\tchar buf[len];\n\n\tsubstring(buf, src, 0, len);\n\n\treturn !strcmp(buf, prefix);\n}\n```\n#### 6.ends_with函数（检测字符串是否以某个字符串结尾）\n```c\n/**\n * To check if the string end with specified string.\n *\n * @param  src    source string pointer\n * @param  suffix suffix string poniter\n * @return        ture if end with specified string, otherwise return false\n */\nbool ends_with(const char *src, const char *suffix)\n{\n\tint len = strlen(suffix);\n\tchar buf[len];\n\n\tsubstring(buf, src, strlen(src) - len, strlen(src));\n\n\treturn !strcmp(buf, suffix);\n}\n```\n其中starts_with和ends_with使用了substring函数，其他函数都可以单独使用。","tags":["c"],"categories":["c"]},{"title":"TextView实现跑马灯效果","url":"%2F2015%2F07%2F21%2Fandroid-marquee%2F","content":"\n最近在自己的音乐播放器项目中要加入跑马灯效果，于是便研究了下。跑马灯效果是TextView自带的一个属性，使用TextView来实现单个、多个跑马灯效果比较简单。\n<!-- more -->\n#### 1.单个跑马灯效果\n这种比较简单，只需要在布局文件中加入几个属性就可以了：\n```xml\n<TextView\n\tandroid:ellipsize=\"marquee\"\n\tandroid:focusable=\"true\"\n\tandroid:focusableInTouchMode=\"true\"\n\tandroid:marqueeRepeatLimit=\"marquee_forever\"\n\tandroid:singleLine=\"true\" />\n```\n#### 2.多个跑马灯效果\n在同一个layout中，两个TextView如果都设置了焦点，只有后一个会处于focused的状态，这个时候需要写一个类来继承TextView，稍作修改即可：\n```java\npublic class MarqueeView extends TextView {\n\tpublic MarqueeView(Context context) {\n\t\tthis(context, null);\n\t}\n\n\tpublic MarqueeView(Context context, AttributeSet attrs) {\n\t\tthis(context, attrs, 0);\n\t}\n\n\tpublic MarqueeView(Context context, AttributeSet attrs, int defStyleAttr) {\n\t\tsuper(context, attrs, defStyleAttr);\n\t}\n\n\t@Override\n\tprotected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {\n\t\tsuper.onFocusChanged(true, direction, previouslyFocusedRect);\n\t}\n\n\t@Override\n\tpublic void onWindowFocusChanged(boolean hasWindowFocus) {\n\t\tsuper.onWindowFocusChanged(true);\n\t}\n\n\t@Override\n\tpublic boolean isFocused() {\n\t\treturn true;\n\t}\n}\n```\n然后就可以在布局文件中使用了：\n```xml\n<MarqueeView\n\tandroid:ellipsize=\"marquee\"\n\tandroid:marqueeRepeatLimit=\"marquee_forever\"\n\tandroid:singleLine=\"true\" />\n```\n#### 3.在appwidget中实现跑马灯效果\nappwidget比较特殊，它只支持几个固定的view，所以就不能实现多个跑马灯效果，只能实现单个效果，不过和在普通layout中的实现稍微有所不同：\n```xml\n<TextView\n\tandroid:ellipsize=\"marquee\"\n\tandroid:focusable=\"true\"\n\tandroid:focusableInTouchMode=\"true\"\n\tandroid:marqueeRepeatLimit=\"marquee_forever\"\n\tandroid:singleLine=\"true\">\n\t<requestFocus\n\t\tandroid:duplicateParentState=\"true\"\n\t\tandroid:focusable=\"true\"\n\t\tandroid:focusableInTouchMode=\"true\"/>\n</TextView>\n```\n需要在TextView中加入requestFocus标签才可以实现跑马灯效果。","tags":["widget"],"categories":["android"]},{"title":"Android JNI注册的两种方式","url":"%2F2015%2F07%2F10%2Fjni_register%2F","content":"\nAndroid JNI开发时，如何注册JNI的方法，Java才能调用，下面说一下JNI的两种注册方法。\n\n#### 第一种方法：静态注册\n所谓静态注册就是调用java的命令工具javah来生成头文件，然后再实现头文件中的所有函数即可。这种方法比较简单，首先在命令行中（我这里使用的是windows cmd，linux、mac是一样的），进入到src目录下，然后执行：\n```shell\n$ javah -d E:\\SourceCode\\Android\\JniTest\\ -jni com.coolerfall.HelloJni\n```\n其中-d表示生成的头文件的输出目录，可以自行设置，com.coolerfall.HelloJni是包含有native方法的类，native方法如：\n```java\npublic static native void init();\n```\n最后生成一个com_coolerfall_player_HelloJni.h头文件，接下来就可以新建一个c文件实现这些函数就ok了。\n<!-- more -->\n#### 第二种方法：动态注册\n静态方法虽然用起来方便，只需要使用一句命令行就搞定了，但是这种方法我们不知道jni的注册过程是怎样的，而且如果新添加一个方法后，又得重新生成一次，比较麻烦，动态注册就可以避免这个问题。和静态注册的区别在于，不使用javah，而由我们自己来写注册函数等等。\n　　我们可以新建一个c文件，比如init.c，然后在里面添加\n```c\n#include <jni.h>\n\nstatic JNINativeMethod g_methods[] = {\n\t{\"init\", \"()V\", (void *)init},\n\t{\"start\", \"(Ljava/lang/String;JJ)V\", (void *)start},\n};\n\nint register_native_methods(JNIEnv* env, const char* class_name,\n\t\tJNINativeMethod* methods, int num_methods)\n{\n\tjclass clazz;\n\tclazz = (*env)->FindClass(env, class_name);\n\tif (clazz == NULL) {\n\t\treturn JNI_FALSE;\n\t}\n\tif ((*env)->RegisterNatives(env, clazz, methods, num_methods) < 0) {\n\t\treturn JNI_FALSE;\n\t}\n\n\treturn JNI_TRUE;\n}\n\njint JNI_OnLoad(JavaVM *vm, void *reserved)\n{\n\tJNIEnv* env = NULL;\n\n\tif ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_4) != JNI_OK)\n\t{\n\t\treturn 0;\n\t}\n\n\tif (!register_native_methods(env, \"com/coolerfall/HelloJni\", g_methods,\n\t\t\tsizeof(g_methods) / sizeof(g_methods[0])))\n\t{\n\t\treturn 0;\n\t}\n\n\treturn JNI_VERSION_1_4;\n}\n```\nJava层调用System.loadLibrary(\"xxx\")的时候，会首先进入JNI_OnLoad这个函数里面，因此，我们就在这里面调用register_native_methods对JNI的一些列方法进行注册，最终在register_native_methods调用了jni函数RegisterNatives来对native方法注册到对应的类上去，这样就完成了jni的注册，java就可以调用jni的方法了。使用这种方法时，添加一个native方法就非常方便了，直接在g_methods数组里面添加新的方法即可。\n\n关于g_methods数组里面方法的签名规则可以查看[Android JNI类型、方法签名规范][1]。\n\n\n[1]: http://coolerfall.com/android/jni-signature/","tags":["jni"],"categories":["android"]},{"title":"Android JNI类型、方法签名规范","url":"%2F2015%2F07%2F04%2Fjni-signature%2F","content":"\n在Android开发中不免会使用到JNI，JNI编程中可以使用javah等工具自动生成jni的头文件，但是如果想自己手动注册，那么就需要了解JNI方法的签名规范，记录一下，以备以后查看。\n<!-- more -->\n\n| Java类型 |  Native类型  | JNI签名 |\n| :------: | :----------: | :-----: |\n| boolean  |   jboolean   |    Z    |\n|   byte   |    jbyte     |    B    |\n|   char   |    jchar     |    C    |\n|  short   |    jshort    |    S    |\n|   int    |     jint     |    I    |\n|   long   |    jlong     |    J    |\n|  float   |    jfloat    |    F    |\n|  double  |   jdouble    |    D    |\n|  byte[]  |  jbyteArray  |   [B    |\n|  char[]  |  jcharArray  |   [C    |\n| short[]  | jshortArray  |   [S    |\n|  int[]   |  jintArray   |   [I    |\n|  long[]  |  jlongArray  |   [L    |\n| float[]  | jfloatArray  |   [F    |\n| double[] | jdoubleArray |   [D    |\n| Java类(例: String) | jstring/jobject | L全类名;(例: Ljava/lang/String; |\n| Java方法(例: start(String path, long pos, long duration)) | Native方法(例: start(jstring path, jlong pos, jlong duration)) | (参数签名...)返回值签名(例: (Ljava/lang/String;JJ)V) |\n\n要注意的是java类的签名，最后的分号不要忘记。String类比较特别，jni提供了就jstring与之对应，java方法签名中，括号里面是所有参数的类型签名，中间无间隔，括号外面是返回值类型签名。","tags":["jni"],"categories":["android"]},{"title":"linux shell报错bad interpreter No such file or directory","url":"%2F2015%2F06%2F24%2Fbad-interpreter%2F","content":"\n最近在linux使用ndk编译一些东西，就使用到了shell脚本，结果在执行的时候出现：\n\t\n\tbash: ./build_android.sh: /bin/bash^M: bad interpreter: No such file or directory\n\n使用vim打开shell脚本，发现并没有问题，最后发现是由于shell脚本在windows下编写的，copy到linux后文本格式不对，所以只需要更改一下文本格式就可以了，用vim打开shell脚本，在命令行模式下：\n\n\t:set fileformat=unix\n\n最后保存退出就可以执行了。","tags":["shell"],"categories":["tools"]},{"title":"Android activity的四种launchMode","url":"%2F2015%2F06%2F03%2Fandroid-launch-mode%2F","content":"\nAndroid的四种launchMode是我们比较常用的基础点，但是有时候很容易就混淆了。Activity一共有四种启动方式：standard、singleTask、singleInstance、singleTop，四种方式各有个的特点，在不同情况下会使用不同的启动方式。\n<!-- more -->\n\n#### 1. standard启动方式\n这种方式是sdk种默认的方式，如果不给activity设置启动方式，那么就会默认的采用这种启动方式，这种方式在调用startActivity的时候，不管之前是否启动过，系统都会重新创建一个实例出来\n#### 2. singleTask启动方式\n如果有其他task已经创建了这个activity，则会直接调用这个实例\n#### 3. singleInstance启动方式\n新建一个task，并且该task中有且只有一个该activity的实例，如果后面再次调用startActivity，会重用这个实例\n#### 4. singleTop启动方式\n如字面意思，在task栈顶只有一个实例，也就是如果当前栈顶是acticity A，如果启动intent又跳转到A，则不会产生新的实例，但如果A最初不在栈顶，则会产生一个实例（如：任务栈 A B C D，D在栈顶，这个时候有Intent启动了D，则启动后的任务栈情况为A B C D；如果有Intent启动了B，则任务栈的情况为： A B C D B。\n以上为activity的四种方式，比较容易混淆，记录下来以备查看。","tags":["launch mode"],"categories":["android"]},{"title":"记录git使用中遇到的一些小问题","url":"%2F2015%2F05%2F14%2Fgit-problems%2F","content":"\n现在在项目中git的使用已经比较频繁了，难免会遇到各种各样的小问题，这里记录下这些问题。\n#### 1.在push大文件的时候遇到\n\n\terror: RPC failed; result=22, HTTP code = 411\n\tfatal: The remote end hung up unexpectedly\n\tfatal: The remote end hung up unexpectedly\n这个是因为http buffer不够造成的，可以简单配置git来解决：\n\t\n\tgit config http.postBuffer 67108864\n#### 2.想要把已经push的文件（夹）加入到.ignore中\n直接添加到.ignore中是不能成功的，因为已经push到服务器了，需要先删除本地缓存的文件：\n```shell\n$ git rm -r --cached .idea\n```\n然后再将其添加到.ignore中，最后git push就ok了","tags":["git"],"categories":["tools"]},{"title":"Android taskAffinity与桌面快捷方式","url":"%2F2015%2F04%2F03%2Fandroid-task-affinity%2F","content":"\n最近在做一个像豌豆荚游戏文件类似的东西，但是遇到个奇怪的问题，就是应用打开后home键退出，然后再点击文件夹，会同时弹出文件夹以及home退出之前的界面，经过一番折腾，算是整明白了问题。首先说说taskAffinity，每个application创建的时候，都会有taskAffinity，默认情况下同一个application下的所有activity都属于同一个taskAffinity，都会在相同的task中。而这里创建的文件夹快捷方式，相当于是让其指定到了应用的某个acitivity，如果没有给这个activity指定taskAffinity的话，那么将会与前面的activity运行在相同的task中，也就是在打开快捷方式后，若前面的activity未finish掉，这个时候会从栈中弹出，出现我所遇到的问题。最后在文件夹快捷方式指定的activity中加入`android:taskAffinity=\":icon\"`，问题就解决了。","tags":["taskAffinity"],"categories":["android"]},{"title":"使用gradle将项目上传到maven中央库","url":"%2F2015%2F03%2F28%2Fgradle-push-to-maven%2F","content":"\n用AS开发也有一段时间了，发现AS可以使用maven，在gradle中可以很方便的解决依赖问题，再也不用去下载相应的jar包了。gradle添加一些依赖库比较方便，但是如果想把自己的一些开源项目上传到maven中央库给别人使用，就稍微有些麻烦了。现在比较简单的办法是先将自己在github上的项目提交到Sonatype，然后再同步到maven中央库去，大致说一下流程。\n\n<!-- more -->\n\n#### 注册JIRA账号\n要想把项目提交到Sonatype，首先得得去[Sonatype Issue][1]去注册一个JIRA账号，注册流程很简单，挨着填写就ok了，这个账号在后面配置的时候要用到。\n#### 创建一个issue\n账号注册好之后，就开始创建一个issue，这个issue对应你的一个项目，在上面导航栏中有个Create按钮：\n![img][6]\n然后再弹出的对话框中填写项目的信息：\n![img][7]\n![img][8]\n其中Group Id很重要，一般为自己的域名，这个在后面提交项目的时候要用到。创建好issue后，接下来就是等待，然后工作人员会给你发送邮件。这个时候可以在导航栏中的Issue中找到自己创建的issue，到下面的comments可以看到工作人员问你之前填写的group id这个域名是否是你的，回答是，然后工作人员就会让你提交你的项目到Sonatype:\n![img][9]\n#### 生成GPG密钥，用于上传的文件加密和签名\nlinux下可以直接使用gpg。windows上则可以使用git自带的gpg(如果没有安装git，可以直接安装[gpg4win][3])，在cmd中执行：\n```shell\n$ gpg --gen-key\n```\n姓名，邮箱以及备注要认真填写，最后要求输入passphase，这个是密码，上传maven要用到。\n\n```shell\n$ gpg --list-keys --keyid-format SHORT\n/home/xxxx/.gnupg/pubring.kbx\n-------------------------------\npub   rsa4096/BB090204 2019-01-03 [SC]\n      7B0A1A36C235E95636B75C53D781EED2BB090204\nuid           [ultimate] Vincent Cheung (coolerfall.com) <coolingfall@gmail.com>\nsub   rsa4096/9123FD1A 2019-01-03 [E]\n```\n\n其中BB090204是key id，接下来将公钥上传至服务器：\n```shell\n$ gpg --keyserver hkp://pool.sks-keyservers.net --send-keys BB090204\n```\n\ngpg 2.1之后需要手动导出secring：\n```shell\ngpg --keyring secring.gpg --export-secret-keys > ~/.gnupg/secring.gpg\n```\n\n#### 使用gradle提交项目到Sonatype\n在网上找到了Chris Banes写的[gradle-mvn-push.gradle][4]脚本，参照这个基本就可以了，然后将这个脚本在你项目的`build.gradle`的最后加入`apply from: '../maven_push.gradle'`，如果想发布jar，需要在脚本中加入：\n```groovy\nartifacts {\n\tarchives packageReleaseJar\n}\n```\n\n然后需要在项目下的`gradle.properties`中加入相应参数的值：\n```text\nVERSION_NAME=1.3.0\nPOM_GROUP_ID=com.coolerfall\nPOM_NAME=Http Download Manager\nPOM_ARTIFACT_ID=android-http-download-manager\nPOM_DESCRIPTION=An useful and effective http/https download manager for Android, support breakpoint downloading\nPOM_URL=https://github.com/Coolerfall/Android-HttpDownloadManager\nPOM_SCM_URL=https://github.com/Coolerfall/Android-HttpDownloadManager\nPOM_SCM_CONNECTION=scm:git@github.com:Coolerfall/Android-HttpDownloadManager.git\nPOM_SCM_DEV_CONNECTION=scm:git@github.com:Coolerfall/Android-HttpDownloadManager.git\nPOM_LICENCE_NAME=The Apache Software License, Version 2.0\nPOM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt\nPOM_LICENCE_DIST=repo\nPOM_PACKAGING=jar\n\nPOM_DEVELOPER_ID=coolerfall\nPOM_DEVELOPER_NAME=Vincent Cheung\nPOM_INCEPTION_YEAR=2014\n```\n\nVERSION_NAME如果后面带有SNAPSHOT字符串将会提交到[snapshots][5]，这个不需要同步就可以下载jar以及源码等，如果不加则是发布release版本，这个就需要同步到maven center了。然后还需要在`C:/Users/xxx/.gradle/gradle.properties`中添加Sonatype账号、密码以及签名信息\n```text\nNEXUS_USERNAME=username\nNEXUS_PASSWORD=password\n\nsigning.keyId=BB090204\nsigning.password=password\nsigning.secretKeyRingFile=C:/Users/xxx/AppData/Roaming/gnupg/secring.gpg\n```\n其中signing.password就是刚刚生成gpg时候的passphase。接下来就可以使用gralde提交项目：\n```shell\n$ %GRADLE_HOME%/bin/gradle uploadArchives\n```\n我使用的是AS最新版本，gradle home在AS目录下（如果不是请自行找到gradle home）\n登陆到[Sonatype Nexus][2]，查看Staging Repositories，然后在搜索中过滤出你的Group Id，就可以看到你刚刚提交的项目，接下来发布release版本了，先close再Release:\n![img][11]\n然后在[Sonatype Issue][1]给工作人员回复，你已经成功发布，让他们帮你同步到maven中央库去：\n![img][10]\n最后就是等待工作人员给你同步，成功同步后，一般10几分钟左右就可以在[maven center][12]搜索到你的项目了，这样就可以在AS中使用gradle来添加依赖了。如果对[gradle-mvn-push.gradle][4]配置还有什么疑问，请参考我的项目：[Android-HttpDownloadManger][13]。\nps:如果创建issue的时候，工作人员回复`Only one JIRA issue per top-level groupId is necessary. You should already have all the necessary permissions to deploy and new artifacts to this groupId or to any sub-groups thanks to OSSRH-14919.`, 说明之前已经成功的release了一个项目，就不需要再创建一个新的issue了，直接将项目提交到[snapshots][5]，并进行closed和realease操作即可，过10分钟左右就可以在gradle中使用了。\n\n[1]: https://issues.sonatype.org\n[2]: https://oss.sonatype.org/\n[3]: http://gpg4win.org/\n[4]: https://raw.githubusercontent.com/chrisbanes/gradle-mvn-push/master/gradle-mvn-push.gradle\n[5]: https://oss.sonatype.org/content/repositories/snapshots\n[6]: /uploads/gradle-maven/new-issue.jpg\n[7]: /uploads/gradle-maven/create_issue1.jpg\n[8]: /uploads/gradle-maven/create_issue2.jpg\n[9]: /uploads/gradle-maven/comments1.jpg\n[10]: /uploads/gradle-maven/comments2.jpg\n[11]: /uploads/gradle-maven/release.jpg\n[12]: http://search.maven.org/\n[13]: https://github.com/Coolerfall/Android-HttpDownloadManager","tags":["maven"],"categories":["android"]},{"title":"Android App Uninstall Watcher","url":"%2F2015%2F03%2F25%2Fandroid-app-uninstall-watcher%2F","content":"\n很多应用在卸载后都会弹出一个网页做用户卸载反馈，这就需要监听App的卸载，但是应用一旦卸载就不会再执行任何程序了，如何才能弹出网页，答案就是在应用开启时就fork出一个子进程来，在进程中对App进行卸载监听。在linux中有个东西叫inotify，可以对指定的文件进行监听（包括修改，删除等等），基本的流程就是inotify_init->inotify_add_watch->inotify_event，在inotify_event读取操作的时候是阻塞的，一直会等到指定的文件变动后才会往下执行。\n<!-- more -->\n```c\nint main(int argc, char *argv[])\n{\n\tchar *app_dir = \"/data/data/com.xx.yy\";\n\tchar *watch_file_path = str_stitching(app_dir, \"/uninstall.watch\");\n\n\tpid_t pid = fork();\n\tif (pid < 0)\n\t{\n\t\treturn;\n\t}\n\telse if (pid == 0)\n\t{\n\t\t/* inotify init */\n\t\tint fd = inotify_init();\n\t\tif (fd < 0)\n\t\t{\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tint w_fd = open(watch_file_path, O_RDWR | O_CREAT | O_TRUNC,\n\t\t\t\tS_IRWXU | S_IRWXG | S_IRWXO);\n\t\tif (w_fd < 0)\n\t\t{\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tclose(w_fd);\n\n\t\t/* add watch in inotify */\n\t\tint watch_fd = inotify_add_watch(fd, watch_file_path, IN_DELETE);\n\t\tif (watch_fd < 0)\n\t\t{\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tvoid *p_buf = malloc(sizeof(struct inotify_event));\n\t\tif (p_buf == NULL)\n\t\t{\n\t\t\tLOGD(LOG_TAG, \"malloc inotify event failed\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t/* read will block process */\n\t\tread(fd, p_buf, sizeof(struct inotify_event));\n\n\t\tfree(p_buf);\n\t\tinotify_rm_watch(fd, IN_DELETE);\n\n\t\topen_browser(url);\n\t}\n}\n```\n\n与[App Daemon][1]一样，使用命令行的方式来调用wathcer，所有这里也`int main(int argc, char *argv[])`，最终将这个c文件编译成可执行文件。为了要监听某个文件的删除，首先在/data/data/<packagename>/下新建了一个uninstall.watch文件，在后面我们将对此文件进行监听，然后同样的，为了不妨碍主进程，这里fork出一个子进程，在子进程里面进行操作。接下来是关键的地方：调用`inotify_init()`初始化inotify，接着将刚刚新建的uninstall.watch文件加入`inotify_add_watch(fd, watch_file_path, IN_DELETE)`中监听，这里是监听该文件的删除（第三个参数还可以是IN_CREATE, IN_MODIFY, IN_MOVED_TO等等，根据需求更改），接下来就是读取`read(fd, p_buf, sizeof(struct inotify_event))`，这个函数会一直阻塞直到条件满足才会继续往下执行，最后释放并加入打开浏览器。打开浏览器也比较简单了:\n```c\n/* open browser with specified url */\nvoid open_browser(char *url)\n{\n\t/* the url cannot be null */\n\tif (url == NULL || strlen(url) < 4) {\n\t\treturn;\n\t}\n\n\t/* get the sdk version */\n\tchar value[8] = \"\";\n\t__system_property_get(\"ro.build.version.sdk\", value);\n\n\tint version = atoi(value);\n\t/* is the version is greater than 17 */\n\tif (version >= 17 || version == 0)\n\t{\n\t\texeclp(\"am\", \"am\", \"start\", \"--user\", \"0\",\n\t\t\t\t\"-a\", \"android.intent.action.VIEW\", \"-d\", url, (char *)NULL);\n\t}\n\telse\n\t{\n\t\texeclp(\"am\", \"am\", \"start\", \"-a\", \"android.intent.action.VIEW\", \"-d\", url, (char *)NULL);\n\t}\n}\n```\n和[App Daemon][1]类似，也是使用execlp来调用am命令打开默认浏览器，最后就会弹出一个指定的网页了。\n　　以上是卸载监听的基本流程，但我在实际操作过程中遇到了比如调试应用，实际上是覆盖，但这时候也会弹出网页等等，所有在子进程中的操作有所改动和优化，并在打开浏览器前使用了[libcurl][2]请求服务器，以满足不需要打开网页的需求，具体请查看[wathcer.c][3]。\n\nps:此方法和[App Daemon][1]一样由于系统原因不能适配所有手机，请注意。\n\n[1]: http://coolerfall.com/android/android-app-daemon\n[2]: http://curl.haxx.se/libcurl/\n[3]: https://github.com/Coolerfall/Android-AppUninstallWatcher/blob/master/app/src/main/jni/watcher/watcher.c","tags":["ndk"],"categories":["android"]},{"title":"Android App Daemon","url":"%2F2015%2F03%2F23%2Fandroid-app-daemon%2F","content":"\n一直没空把App Daemon的原理整理一下，见不少人在问原理，我这里就把整个流程大概的说一下。关于进程守护，从接触Android没多久就一直想实现，网上给出的方案也是各种各样，有双服务方式，有利用系统定时器方式的等等等等，但我都有过尝试，最终都没有达到自己想要的结果。后来想到自己以前在搞linux的时候用到子进程来处理一些任务，而Android正是基于linux的，觉得这样的话应该是可行的。最初直接在JNI的c代码中fork出一个子进程出来，然后在子进程中加一个while(1)，再在while中sleep并打开一个指定的service，这样一个最简单的守护完成了。但是后来测试发现，虽然能实现功能，不过使用adb shell查看进程(命令: ps | grep com.coolerfall....)，发现fork出来的进程的VSIZE(进程虚拟地址空间大小)和RSS(进程正在使用的物理内存的大小)都很大，而且UI线程有时候会出现莫名其妙的问题，于是进程守护也就暂时放下了。后来由于项目需求，又不得不开始折腾进程守护。一次在看开源项目[afwall][1](android上的流量防火墙)，发现其中的命令是直接使用linux命令行的方式在执行的，这才想起linux可以直接编译一个可执行的二进制文件，然后在命令行中直接执行。看了看Android.mk的文档，加入`include $(BUILD_EXECUTABLE)`可以让c文件编译成在Android上运行的二进制文件，最后把以前的代码直接拿过来，一切OK了。\n<!-- more -->\n原理分析：\n```c\nint main(int argc, char *argv[])\n{\n\tint i;\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0)\n\t{\n\t    exit(EXIT_SUCCESS);\n\t}\n\telse if (pid == 0)\n\t{\n\t\t/* child process become session leader */\n\t\tsetsid();\n\t\t/* change work directory */\n\t\tchdir(\"/\");\n\n\t\tfor (i = 0; i < 3; i ++)\n\t\t{\n\t\t\tclose(i);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tsleep(interval);\n\n\t\t\tLOGD(LOG_TAG, \"check the service once\");\n\n\t\t\t/* start service */\n\t\t\tstart_service(package_name, service_name);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* parent process, do nothing */\n\t}\n}\n```\n由于要在shell中直接执行，因此这里使用`int main(int argc, char *argv[])`，让可执行文件有入口。frok出子进程之后，让子进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离，紧接着就是在子进程中定时去启动服务，这样一个简单的进程守护就OK了。\n其中`start_service`为启动一个Service:\n```c\n/* start daemon service */\nstatic void start_service(char *package_name, char *service_name)\n{\n\t/* get the sdk version */\n\tint version = get_version();\n\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0)\n\t{\n\t\texit(EXIT_SUCCESS);\n\t}\n\telse if (pid == 0)\n\t{\n\t\tif (package_name == NULL || service_name == NULL)\n\t\t{\n\t\t\tLOGE(LOG_TAG, \"package name or service name is null\");\n\t\t\treturn;\n\t\t}\n\n\t\tchar *p_name = str_stitching(package_name, \"/\");\n\t\tchar *s_name = str_stitching(p_name, service_name);\n\t\tLOGD(LOG_TAG, \"service: %s\", s_name);\n\n\t\tif (version >= 17 || version == 0)\n\t\t{\n\t\t\tint ret = execlp(\"am\", \"am\", \"startservice\",\n\t\t\t\t\t\t\"--user\", \"0\", \"-n\", s_name, (char *) NULL);\n\t\t\tLOGD(LOG_TAG, \"result %d\", ret);\n\t\t}\n\t\telse\n\t\t{\n\t\t\texeclp(\"am\", \"am\", \"startservice\", \"-n\", s_name, (char *) NULL);\n\t\t}\n\n\t\tLOGD(LOG_TAG , \"exit start-service child process\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\telse\n\t{\n\t\twaitpid(pid, NULL, 0);\n\t}\n}\n```\n这里说明下：execlp执行后，如果没有错误则不返回，有错时才有返回值，因此又fork了一个子进程，然后在子进程中启动指定的Service。其次是Android SDK版本小于17的执行命令有所不同，17及以上命令为：`execlp(\"am\", \"am\", \"startservice\",\n\"--user\", \"0\", \"-n\", s_name, (char *) NULL)`, 17以下:`execlp(\"am\", \"am\", \"startservice\", \"-n\", s_name, (char *) NULL)`。获取version比较简单:\n```c\n#include <sys/system_properties.h>\n\n/**\n * Get the version of current SDK.\n */\nint get_version()\n{\n\tchar value[8] = \"\";\n    __system_property_get(\"ro.build.version.sdk\", value);\n\n    return atoi(value);\n}\n```\n由于编译出来的是可执行的二进制文件，所以调用就不像so库那样了。需要将可执行文件放在assets中，并在执行的时候将其copy至/data/data/packagename/app_bin文件夹下，然后在java中这样调用: \n```java\nString cmd = \"/data/data/<packagename>/app_bin/daemon\"\nRuntime.getRuntime().exec(cmd);\n```\n进程守护大致的原理就是这样了，只要搞清楚了原理，其实是进程守护并不复杂。\n\nps: 并不是所有手机都能用此方法实现进程守护，有的手机（如小米），自带清理进程会清理掉应用相关的所有进程。5.x以上可参考[MarsDaemon][2].\n\n\n[1]: https://github.com/ukanth/afwall\n[2]: https://github.com/Marswin/MarsDaemon","tags":["ndk"],"categories":["android"]},{"title":"golang计算字符以及文件的hash值","url":"%2F2015%2F03%2F19%2Fgolang-hash%2F","content":"\n学习golang一段时间了，逐渐开始编写一些工具使用，最近需要用来计算hash值。使用golang来计算字符和文件的hash值(md5, sha1, sha256)比较简单。\n<!-- more -->\n\n计算字符串的hash比较简单，直接上代码：\n```go\nfunc md5Str(origin string) string {\n\tm := md5.New()\n\tm.Write([]byte(origin))\n\treturn hex.EncodeToString(m.Sum(nil))\n}\n```\n\n计算文件的hash值稍微麻烦一点：\n```go\nfunc md5File(filepath string) string {\n\tfile, err := os.Open(filepath)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tdefer file.Close()\n\n\tm := md5.New()\n\t_, err = io.Copy(m, file)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\treturn hex.EncodeToString(m.Sum(nil))\n}\n```\n\nsha1和sha256的计算方法类似，具体的代码已经提交至[github][1]上。\n\n[1]: https://github.com/Coolerfall/go-utils/blob/master/hash.go","tags":["hash"],"categories":["go"]},{"title":"Android监听Home键","url":"%2F2015%2F03%2F16%2Flisten-home-key%2F","content":"\nAndroid的Home比较特殊，不能像其他键(如返回键)那样直接用onKeyDown或onKeyUp来监听，需要用其他的方法来实现监听。\n<!-- more -->\n\n在Home键按下时，系统会发出一个广播，我们只需要注册一个Receiver来接收这个广播即可：\n```java\npublic class HomeKeyReceiver extends BroadcastReceiver {\n\tprivate static final String TAG = HomeKeyReceiver.class.getSimpleName();\n\t\n\t/* extra from home key broadcase receiver */\n\tprivate static final String SYSTEM_DIALOG_REASON_EXTRA = \"reason\";\n    /* press home key to go back to home */\n    private static final String SYSTEM_DIALOG_REASON_HOME_KEY = \"homekey\";\n\t/* long press home key to show recent apps */\n    private static final String SYSTEM_DIALOG_REASON_RECENT_APPS = \"recentapps\";\n    /* (long) press home key to show assistant */\n    private static final String SYSTEM_DIALOG_REASON_ASSIST = \"assist\";\n    /* (long) press home key to lock */\n    private static final String SYSTEM_DIALOG_REASON_LOCK = \"lock\";\n\t\n\tprivate Context mContext;\n\t/* listeners used in this broadcast receiver */\n\tprivate OnHomeKeyListener mOnHomeKeyListener;\n\tprivate OnRecentAppListener mOnRecentAppListener;\n\tprivate OnAssistListener mOnAssistListener;\n\tprivate OnLockListener mOnLockListener;\n\t\n\tpublic HomeKeyReceiver(Context context) {\n\t\tmContext = context;\n\t}\n\t\n\t/**\n\t * Interface definition for a callback to be invoked when the reason is \"homekey\".\n\t */\n\tpublic interface OnHomeKeyListener {\n\t\tvoid onKeypressed();\n\t}\n\t\n\t/**\n\t * Interface definition for a callback to be invoked when the reason is \"recentapps\".\n\t */\n\tpublic interface OnRecentAppListener {\n\t\tvoid onKeypressed();\n\t}\n\t\n\t/**\n\t * Interface definition for a callback to be invoked when the reason is \"assist\".\n\t */\n\tpublic interface OnAssistListener {\n\t\tvoid onKeypressed();\n\t}\n\t\n\t/**\n\t * Interface definition for a callback to be invoked when the reason is \"lock\".\n\t */\n\tpublic interface OnLockListener {\n\t\tvoid onKeypressed();\n\t}\n\t\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\tif (intent.getAction().equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {\n\t\t\tString reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_EXTRA);\n\t\t\tif (TextUtils.isEmpty(reason)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tswitch (reason) {\n\t\t\tcase SYSTEM_DIALOG_REASON_HOME_KEY:\n\t\t\t\tif (mOnHomeKeyListener != null) {\n\t\t\t\t\tmOnHomeKeyListener.onKeypressed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase SYSTEM_DIALOG_REASON_RECENT_APPS:\n\t\t\t\tif (mOnRecentAppListener != null) {\n\t\t\t\t\tmOnRecentAppListener.onKeypressed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase SYSTEM_DIALOG_REASON_ASSIST:\n\t\t\t\tif (mOnAssistListener != null) {\n\t\t\t\t\tmOnAssistListener.onKeypressed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase SYSTEM_DIALOG_REASON_LOCK:\n\t\t\t\tif (mOnLockListener != null) {\n\t\t\t\t\tmOnLockListener.onKeypressed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tLog.d(TAG, \"other reason: \" + reason);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Register a callback to be invoked when system dialog reason is \"homekey\".\n\t */\n\tpublic void setOnHomeKeyListener(OnHomeKeyListener l) {\n\t\tmOnHomeKeyListener = l;\n\t}\n\t\n\t/**\n\t * Register a callback to be invoked when system dialog reason is \"recentapps\".\n\t */\n\tpublic void setOnRecentAppListener(OnRecentAppListener l) {\n\t\tmOnRecentAppListener = l;\n\t}\n\t\n\t/**\n\t * Register a callback to be invoked when system dialog reason is \"assist\".\n\t */\n\tpublic void setOnAssistListener(OnAssistListener l) {\n\t\tmOnAssistListener = l;\n\t}\n\t\n\t/**\n\t * Register a callback to be invoked when system dialog reason is \"lock\".\n\t */\n\tpublic void setOnLockListener(OnLockListener l) {\n\t\tmOnLockListener = l;\n\t}\n\n\t/**\n\t * Register the home key boradcasr receiver.\n\t */\n\tpublic void register() {\n\t\tIntentFilter homeFilter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);\n\t\tmContext.registerReceiver(this, homeFilter);\n\t}\n\t\n\t/**\n\t * Unregister the home key boradcasr receiver.\n\t */\n\tpublic void unregister() {\n\t\tmContext.unregisterReceiver(this);\n\t}\n```\n\n由于home键在不同手机上，长/短按有不同的效果，代码列举出常用的几种，其中`homekey`表示短按home键退到桌面。\n\n简单使用：\n```java\nprivate HomeKeyReceiver mHomeKeyReceiver;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\n\tmHomeKeyReceiver = new HomeKeyReceiver(this);\n\tmHomeKeyReceiver.setOnHomeKeyListener(new OnHomeKeyListener() {\n\t\t@Override\n\t\tpublic void onKeypressed() {\n\t\t\tLog.d(TAG, \"home key pressed\");\n\t\t}\n\t});\n}\n\n@Override\nprotected void onResume() {\n\tsuper.onResume();\n\tmHomeKeyReceiver.register();\n}\n\n@Override\nprotected void onPause() {\n\tsuper.onPause();\n\tmHomeKeyReceiver.unregister();\n}\n\n```\n\n注意：这个Receiver需要在`onResume`中注册，在`onPause`中注销。","tags":["home key"],"categories":["android"]},{"title":"Android Studio更新时连接服务器失败问题解决","url":"%2F2015%2F02%2F14%2Fandoird-studio-update%2F","content":"\n最近被墙得厉害，连AS都不能自动更新了，最终找到了个比较简单有效的办法。\n<!-- more -->\n\n解决方法很简单，打开AS安装目录下的bin目录，找到&nbsp;`studio64.exe.vmoptions`&nbsp;（32位找&nbsp;`studio.exe.vmoptions`&nbsp;即可）这个文件，往里面添加几行：\n```text\n-Djava.net.preferIPv4Stack=true\n\n-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n-Didea.patches.url=http://dl.google.com/android/studio/patches/\n```\n保存退出，重启AS，不出意外就能更新了。","tags":["android studio"],"categories":["tools"]},{"title":"Android Studio多渠道批量打包","url":"%2F2015%2F02%2F14%2Fmultiple-channel-packing%2F","content":"\nAndroid市场众多，在打包App的时候需要对每个渠道添加不同的参数用于统计，但是针对每个渠道单独打包比较麻烦，所以要考虑使用批量打包。AS使用gradle来构建android项目，我们可以利用来进行批量打包操作。\n<!-- more -->\n\n### 步骤 ###\n\n1.在manifest中找到与渠道相关的参数，增加相应的PlaceHolder，例如：\n```xml\n<meta-data\n\tandroid:name=\"aid\"\n\tandroid:value=\"${APP_AID}\" />\n\n<meta-data\n\tandroid:name=\"pid\"\n\tandroid:value=\"${APP_PID}\" />\n```\n\n2.在build.gradle设置productFlavors：\n```groovy\nandroid {\n\tproductFlavors {\n\t\twandoujia {\n\t\t\tmanifestPlaceholders = [APP_AID : 80, APP_PID : 43]\n\t\t}\n\n\t\tyingyongbao {\n\t\t\tmanifestPlaceholders = [APP_AID : 60, APP_PID : 45]\n\t\t}\n\t}\n}\n```\nmanifestPlaceholders是一个数组，可以根据实际需求增减参数\n\n3.最后在AS中Build->Generate Signed APK，最后根据提示打包APK，AS会根据productFlavors生成相应的包","tags":["android studio"],"categories":["tools"]},{"title":"在Android Studio中利用gradle来自动编译jni","url":"%2F2015%2F02%2F08%2Fuse-ndk-in-android-studio%2F","content":"\n在最近的Android开发中，项目逐渐从Eclipse迁移到Android Studio中来，google官方现在并未在Android Studio中支持ndk的开发，但是我们可以利用gradle自动编译jni。\n<!-- more  -->\n\n### 步骤 ###\n\n1.在新建项目中找到local.properties，在里面加入ndk的路径(ndk必须是r9以上)：\n```text\nndk.dir=E\\:\\\\Android\\\\ndk-r10d\n```\n\n2.在app\\src\\main中新建jni文件夹，在这里面存放要编译的c/c++文件以及Android.mk\n\n3.在app中的build.gradle中加入两个task：ndkBuild和copyJniLibs，第一个task为ndk执行编译，第二个task将编译好的so库copy至jniLibs目录，这样才Android Studio最后打包的时候才会将so库打包进去：\n```groovy\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion \"21.1.2\"\n    defaultConfig {\n        applicationId \"com.xxx.yyy\"\n        versionCode 1\n        versionName '1.0'\n\t    minSdkVersion 10\n\t    targetSdkVersion 21\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles ('proguard-android.txt')\n        }\n    }\n\n    tasks.withType(JavaCompile) {\n        compileTask -> compileTask.dependsOn 'ndkBuild', 'copyJniLibs'\n    }\n\n    sourceSets {\n        main {\n\t        jni.srcDirs = []\n            jniLibs.srcDirs = ['src/main/jniLibs']\n        }\n    }\n}\n\ntask ndkBuild(type: Exec) {\n\tdef ndkDir = project.plugins.findPlugin('com.android.application').sdkHandler.getNdkFolder()\n    commandLine \"$ndkDir/ndk-build.cmd\", '-C', 'src/main/jni',\n\t\t    \"NDK_OUT=$buildDir/ndk/obj\",\n\t\t    \"NDK_APP_DST_DIR=$buildDir/ndk/libs/\\$(TARGET_ARCH_ABI)\"\n}\n\ntask copyJniLibs(type: Copy) {\n    from fileTree(dir: file(buildDir.absolutePath + '/ndk/libs'), include: '**/*.so')\n    into file('src/main/jniLibs')\n}\n```\n\n这两个task不要放在android{}中，放在android{}外即可，否则无法编译。其中*NDK_APP_DST_DIR*为编译后的库存放的文件夹，根据需求自己设定，我在这里是设置为的buildDir下的nkd文件夹\n\n4.最后编译，Android Studo会自动执行ndkBuild和copyJniLibs这两个task\n\nps:也可以使用命令行的方式来执行这两个task\n    \n    $ gradle ndkBuild copyJniLibs\n使用这个命令前，请先找到gradle的目录下bin目录，并添加到环境变量中去","tags":["ndk"],"categories":["tools"]},{"title":"Windows下使用Jekyll在github pages搭建博客","url":"%2F2015%2F02%2F03%2Fgithub-pages-with-jekyll%2F","content":"\n一直想搭建一个博客来记录些开发中遇到的问题，但是自己对前端不熟悉以及服务器主机等等原因，迟迟没有行动起来。后来发现了github pages这个东西，可以支持用户在github上搭建个人博客，于是乎开始折腾起Jekyll了。\n<!-- more  -->\n\n### Jekyll的简单教程 ###\n1.Jekyll是基于Ruby开发的，所以先安装[rubyinstaller以及DevKit][1]，要注意DevKit需下载与rubyinstaller对应的版本。安装好ruby之后，将DevKit解压，在cmd中切换到DevKit的根目录，执行`$ ruby dk.rb init`生成config.yml配置文件，然后在config.yml添加ruby的安装目录：\n```text\n---\n- E:/Ruby200\n```\n\n注意是*---*下面加*-*和空格最后在cmd中执行`$ ruby dk.rb install`，出现提示：\n```text\n$ ruby dk.rb install\n[INFO] Updating convenience notice gem override for 'E:/Ruby200'\n[INFO] Installing 'E:/Ruby200/lib/ruby/site_ruby/devkit.rb'\n```\n则ruby环境搭建完成了。\n\n2.在cmd中通过gem来安装jekyll，首先使用`$ gem list`查看是否安装liquid，若未安装则执行`$ gem install liquid`，安装完成后再执行`$ gem install jekyll`来安装jekyll。如果安装速度很慢，可以考虑将ruby源更换为淘宝源：\n```\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n*** CURRENT SOURCES ***\n\nhttps://ruby.taobao.org\n```\n如果在执行`$ gem list`出现如下时：\n```text\nERROR:  Could not find a valid gem 'liquid' (>= 0), here is why:\n          Unable to download data from https://rubygems.org/ - SSL_connect returned=1 errno=0 state=SSLv3 read server certificate\nB: certificate verify failed (https://rubygems.org/latest_specs.4.8.gz)\n```\n则需要下载[cacert.pem][3]文件，并添加一个环境变量命名为`SSL_CERT_FILE`指向`cacert.pem`所在路径，然后就可以下载了。\n<br>\n\n3.安装好jekyll后，从github上下载[jekyll bootstrap][2]模板:\n```text\n$ git clone https://github.com/plusjade/jekyll-bootstrap.git jekyll\n$ cd jekyll\n$ jekyll server\n```\n在浏览器中输入localhost:4000，成功的话会看到一个demo网页。\n\n[1]: http://rubyinstaller.org/downloads/\n[2]: https://github.com/plusjade/jekyll-bootstrap/\n[3]: http://curl.haxx.se/ca/cacert.pem","tags":["jekyll"],"categories":["misc"]}]